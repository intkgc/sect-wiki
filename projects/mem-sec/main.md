---
title: Подробная архитектура MemSec (Rust)
---

## 1. Цель проекта

MemSec — это интеллектуальный ассистент, который функционирует как «второй мозг» пользователя. Его основная задача — принимать, структурировать, запоминать и использовать информацию, поступающую от человека в форме диалога:

- хранить знания и воспоминания в долговременной памяти;
    
- поддерживать кратковременный контекст взаимодействия;
    
- находить, извлекать и использовать информацию в нужный момент;
    
- подстраиваться под стиль общения, привычки и интересы пользователя.
    

Архитектура реализуется на языке **Rust** с использованием PostgreSQL, `pgvector` и без сторонних графовых баз данных (

---

## 2. Архитектурные слои

### 2.1 Фронтенд

**Цель:** обеспечить пользовательский ввод и получение ответа в виде живого диалога.

**Технологии:**

- Telegram-бот (`teloxide`)
    
- Web-интерфейс (опционально)
    

**Возможности:**

- Ввод текста, команд, мультимедийных вложений
    

---

### 2.2 Агент (диалоговая логика)

**Цель:** связывать ввод пользователя с памятью, логикой поиска и генерацией ответа.

**Компоненты:**

- LLM (ChatGPT / GPT-4o) через API
    
- Rust-контроллер, управляющий:
    
    - генерацией embedding'ов
        
    - вызовами NLP пайплайна
        
    - логикой кратковременной и долговременной памяти
        

**Функции:**

- Диалоговая логика и маршрутизация
    
- Обработка упоминаний
    
- Извлечение / сохранение информации
    
- Контроль MemSummary и перехода к долговременной памяти
    

---

### 2.3 Кратковременная память (Short-Term Memory)

**Цель:** хранить всё, что нужно для текущего контекста диалога.

**Структура:**

```rust
struct ShortTermMemory {
    message_history: Vec<Message>,          //  буфер диалога
    injected_memories: Vec<MemoryEntry>,   // загруженные воспоминания
    mem_summary: String,                   // краткий текстовый обзор
}
```

**Принцип работы:**

- Хранит последние N сообщений
    
- При каждом новом сообщении:
    
    - Проверка, упоминается ли что-то новое
        
    - Если упоминание неизвестно и отсутствует в MemSummary → обращение к долговременной памяти
        
    - MemSummary обновляется с учётом новых фактов
        

**MemSummary** — компактное представление всего, что известно агенту на данный момент. Генерируется LLM и используется как "второй разум".

---

### 2.4 Долговременная память (Long-Term Memory)

**Цель:** устойчивое хранение всей информации пользователя: мыслей, фактов, знаний, данных о людях и пр.

**Технологии:**

- PostgreSQL с `pgvector` для embedding-поиска
    

**Основная таблица: `memory_entries`**

```rust
struct MemoryEntry {
    id: Uuid,
    user_id: Uuid,
    text: String,
    timestamp: DateTime<Utc>,
    kind: EntryKind,
    topics: Vec<String>,
    entities: Vec<Entity>,
    embedding_global: Vec<f32>,
    embedding_local: Vec<f32>,
    linked_to: Vec<Uuid>
}
```

**Типы EntryKind:**

- `Thought` — размышление
    
- `Fact` — знание / утверждение
    
- `Person` — человек
    
- `Reminder` — напоминание (со временем)
    
- `Preference` — вкусы и предпочтения
    
- `User` — информация о самом пользователе
    
- `Observation` — наблюдение
    
- `Quote` — цитата
    
- `Task` — задание
    

**Связи:**

```rust
struct MemoryLink {
    from: Uuid,
    to: Uuid,
    relation: String,
    weight: f32
}
```

- В базе есть `memory_links` таблица
    
- Обновляется при повторных упоминаниях
    
- Используется в ранжировании результатов
    

---

## 3. Embeddings: Global и Local

**Global Embedding** — общий смысл всей заметки. Сохраняется один на запись (`embedding_global`).

**Local Embeddings** — создаются из чанков (фрагментов текста). Используются для точного поиска по частям записи (`embedding_local`).

**Chunking:**

- Выполняется ChatGPT через function calling
    
- Один MemoryEntry может иметь несколько embedding'ов (в расширении — отдельная таблица `memory_chunks`)
    

---

## 4. Ранжирование результатов

**Порядок поиска:**

1. Генерация query_embedding_global и query_embedding_local
    
2. Векторный поиск по `pgvector`
    
3. Отбор top-K результатов (по глобальному и локальному сходству)
    
4. Расширение по `linked_to`
    

**Формула ранжирования:**

score=α⋅(1/dglobal)+(1−α)⋅(1/dlocal)+β⋅(1/dlinked)score = α·(1/d_global) + (1-α)·(1/d_local) + β·(1/d_linked)

- `α` — вес глобального вектора (0.4–0.6)
    
- `β` — усиление связи с графом (0.1–0.3)
    
- `d_global`, `d_local`, `d_linked` — косинусные расстояния
    

**Дополнительно:**

- Совпадения по `topics`
    
- Совпадения по `entities`
    
- Повышение важности `Reminder`, `Task`, `Person`
    

---

## 5. Процесс добавления информации

1. Пользователь пишет сообщение
    
2. Выполняется:
    
    - NER (распознавание сущностей)
        
    - Chunking
        
    - Embedding (global + local)
        
3. Поиск дубликатов (embedding + entities)
    
4. Формирование `MemoryEntry`
    
5. Связывание с существующими
    
6. Обновление кратковременной памяти и `MemSummary`
    

---

## 6. Процесс извлечения информации

1. Пользователь задаёт вопрос
    
2. Проверка `MemSummary`
    
3. Если факт отсутствует:
    
    - Формируется embedding запроса
        
    - Выполняется поиск по памяти
        
4. Результаты передаются в LLM вместе с текущим контекстом
    
5. Ответ возвращается пользователю
    
6. `MemSummary` уточняется / обновляется
    

---

## 7. Механизмы адаптации

- Усиление связей `MemoryLink` при повторных обращениях
    
- Уменьшение веса устаревших или игнорируемых записей
    
- Поддержка автоматического TTL / архивирования по возрасту
    
- Поддержка пользовательских заметок без участия LLM (прямой ввод через команды)
    

---

## 8. Безопасность и мульти-пользовательская поддержка

- Все записи привязаны к `user_id`
    
- Изоляция в БД
    
- Контроль API-вызовов (rate limit, quota)
    
- Шифрование по необходимости
    
- Валидация входящих сообщений
    

---

## 9. Расширения

- Интерфейс временной ленты воспоминаний
    
- Визуализация связей между мыслями (граф памяти)
    
- Режим генерации отчётов: «что я делал на этой неделе», «какие у меня есть мысли по теме Х»
    

---

## 10. Вывод

Эта архитектура реализует полноценный "второй мозг" с долговременной и кратковременной памятью, семантическим извлечением, гибкой типизацией записей, адаптацией под пользователя и расширением под различные сценарии — от персонального дневника до интеллектуального агента.

Готова для реализации на Rust с использованием PostgreSQL и OpenAI API.